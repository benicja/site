---
export const prerender = false;
import { getCollection } from 'astro:content';
import Layout from '../../layouts/Layout.astro';
import RecipeCard from '../../components/RecipeCard.astro';
import { SESSION_COOKIE, getUserFromSession } from '../../lib/auth';
import { getRecipeHearts, getUserHearts } from '../../lib/hearts';

// Get current user
const sessionId = Astro.cookies.get(SESSION_COOKIE)?.value;
const user = sessionId ? await getUserFromSession(sessionId) : null;

// Get all recipes and sort by date (newest first)
const recipes = await getCollection('recipes');
const sortedRecipes = recipes.sort((a, b) => 
  (b.data.publishDate?.getTime() || 0) - (a.data.publishDate?.getTime() || 0)
);

// Get heart data
const globalHearts = await getRecipeHearts();
const userHearts = user ? await getUserHearts(user.user_email) : new Set();

const formatCategories = (value) => (Array.isArray(value) ? value.join(',') : value);
---

<Layout title="Recipes" description="A collection of our favorite family recipes." user={user}>
  <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 pt-6 pb-16">
    {recipes.length > 0 ? (
      <div class="space-y-6">
        {/* Search & Filters */}
        <div class="space-y-4">
          <div class="w-full">
            <div class="relative">
              <input 
                type="text" 
                id="recipe-search" 
                placeholder="Search recipes..." 
                class="w-full px-5 py-3 bg-gray-50/50 border border-gray-200 rounded-xl focus:outline-none focus:border-gray-400 transition-colors duration-[250ms] font-light text-base"
              />
              <div class="absolute right-5 top-1/2 -translate-y-1/2 text-gray-400">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
                </svg>
              </div>
            </div>
          </div>

          <div class="flex flex-wrap items-center gap-2" data-filter-group>
            {[ 'Breakfast', 'Dinner', 'Dessert' ].map(cat => (
              <button 
                type="button"
                class="filter-btn px-4 py-1.5 rounded-full border border-gray-100 bg-white text-[10px] font-bold uppercase tracking-widest text-gray-400 transition-all duration-100 select-none data-[active=true]:bg-gray-100/50 data-[active=true]:text-gray-900 data-[active=true]:border-gray-400 [&:not([data-active=true])]:hover:text-gray-900 [&:not([data-active=true])]:hover:border-gray-200"
                data-filter="category"
                data-value={cat.toLowerCase()}
                data-active="false"
              >
                {cat}
              </button>
            ))}
            
            {user && (
              <button 
                type="button"
                class="filter-btn px-4 py-1.5 rounded-full border border-gray-100 bg-white text-[10px] font-bold uppercase tracking-widest text-gray-400 transition-all duration-100 select-none flex items-center gap-2 data-[active=true]:bg-red-50/50 data-[active=true]:text-red-500 data-[active=true]:border-red-400 [&:not([data-active=true])]:hover:text-gray-900 [&:not([data-active=true])]:hover:border-gray-200"
                data-filter="hearted"
                data-active="false"
              >
                <svg class="w-3.5 h-3.5 fill-none stroke-current transition-all duration-100" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M4.318 6.318a4.5 4.5 0 000 6.364L12 20.364l7.682-7.682a4.5 4.5 0 00-6.364-6.364L12 7.636l-1.318-1.318a4.5 4.5 0 00-6.364 0z" />
                </svg>
                Favourites
              </button>
            )}
          </div>
        </div>

        <section>
          <div id="recipes-grid" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-x-10 gap-y-10">
            {sortedRecipes.map(recipe => (
              <div 
                class="recipe-item" 
                data-title={recipe.data.title.toLowerCase()}
                data-category={formatCategories(recipe.data.category).toLowerCase()}
                data-hearted={userHearts.has(recipe.slug).toString()}
              >
                <RecipeCard 
                  recipe={recipe} 
                  user={user}
                  isHearted={userHearts.has(recipe.slug)}
                  heartCount={(globalHearts as any)[recipe.slug] || 0}
                />
              </div>
            ))}
          </div>
          <div id="no-results" class="hidden py-32 text-center">
             <h2 class="text-2xl font-serif text-gray-400">No recipes match your search.</h2>
          </div>
        </section>
      </div>
    ) : (
      <div class="py-32 text-center border-t border-gray-100">
         <h2 class="text-2xl font-serif text-gray-400">Our recipe book is currently empty.</h2>
         <p class="text-sm text-gray-400 mt-4 uppercase tracking-widest font-bold">Check back soon for upcoming treats.</p>
      </div>
    )}
  </div>

  <script is:inline>
    function initSearch() {
      const searchInput = document.getElementById('recipe-search');
      const recipeItems = document.querySelectorAll('.recipe-item');
      const recipesGrid = document.getElementById('recipes-grid');
      const noResults = document.getElementById('no-results');
      const filterBtns = document.querySelectorAll('.filter-btn');
      const filterGroup = document.querySelector('[data-filter-group]');

      if (!searchInput) return;


      let activeCategory = null;
      let showHeartedOnly = false;

      const normalize = (str) => str.normalize("NFD").replace(/[\u0300-\u036f]/g, "").toLowerCase();

      function updateGrid() {
        const query = normalize(searchInput.value.trim());
        let hasResults = false;


        recipeItems.forEach(item => {
          const title = normalize(item.getAttribute('data-title') || '');
          const category = item.getAttribute('data-category');
          const isHearted = item.getAttribute('data-hearted') === 'true';

          let matchesSearch = title.includes(query);
          let matchesCategory = true;
          if (activeCategory) {
            const categories = (category || '')
              .split(',')
              .map(cat => cat.trim().toLowerCase())
              .filter(Boolean);
            matchesCategory = categories.includes(activeCategory);
          }
          let matchesHearted = !showHeartedOnly || isHearted;

          const shouldShow = matchesSearch && matchesCategory && matchesHearted;
          item.hidden = !shouldShow;
          if (shouldShow) {
            hasResults = true;
          }
        });

        if (hasResults) {
          noResults.classList.add('hidden');
          recipesGrid.classList.remove('hidden');
        } else {
          noResults.classList.remove('hidden');
          recipesGrid.classList.add('hidden');
        }
      }

      function handleFilterClick(btn) {
        const type = btn.getAttribute('data-filter');
        const value = btn.getAttribute('data-value');
        const wasActive = btn.getAttribute('data-active') === 'true';


        if (type === 'category') {
          if (wasActive) {
            activeCategory = null;
            btn.setAttribute('data-active', 'false');
          } else {
            // Reset other category buttons
            filterBtns.forEach(b => {
              if (b.getAttribute('data-filter') === 'category') {
                b.setAttribute('data-active', 'false');
              }
            });
            activeCategory = value ? value.toLowerCase() : null;
            btn.setAttribute('data-active', 'true');
          }
        } else if (type === 'hearted') {
          showHeartedOnly = !showHeartedOnly;
          btn.setAttribute('data-active', showHeartedOnly.toString());
          const heartSvg = btn.querySelector('svg');
          if (showHeartedOnly) {
            heartSvg?.classList.add('fill-current');
          } else {
            heartSvg?.classList.remove('fill-current');
          }
        }

        updateGrid();
      }

      // Handle Category/Hearted Buttons (delegated)
      filterGroup?.addEventListener('click', (event) => {
        const rawTarget = event.target;
        const element = rawTarget instanceof Element ? rawTarget : rawTarget?.parentElement;
        const btn = element?.closest ? element.closest('.filter-btn') : null;
        if (!btn) return;
        handleFilterClick(btn);
      });

      // Fallback: bind directly to buttons (guards against delegation issues)
      filterBtns.forEach(btn => {
        if (btn.getAttribute('data-inited') === 'true') return;
        btn.setAttribute('data-inited', 'true');
        btn.addEventListener('click', (event) => {
          event.preventDefault();
          handleFilterClick(btn);
        });
      });

      // Handle Search Input
      searchInput.addEventListener('input', updateGrid);

      // Check URL for initial category
      const urlParams = new URLSearchParams(window.location.search);
      const initialCat = urlParams.get('category');
      if (initialCat) {
        const targetBtn = Array.from(filterBtns).find(b => b.getAttribute('data-value') === initialCat);
        if (targetBtn) targetBtn.click();
      }
    }

    // Initialize on load
    initSearch();
    
    // Re-initialize after view transitions
    document.addEventListener('astro:after-swap', initSearch);
    document.addEventListener('astro:page-load', initSearch);
  </script>
</Layout>